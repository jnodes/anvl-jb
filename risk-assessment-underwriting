# ANVL AI Agent Swarm 1: Risk Assessment & Underwriting
# This script provides a functional implementation of the first AI swarm,
# designed to autonomously assess and underwrite dealership loan applications.

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
import asyncio
from enum import Enum
import json

# --- Agent & Data Model Definitions ---

class AgentRole(Enum):
    """Enumeration for the roles of agents in this swarm."""
    CREDIT_ANALYST = "credit_analyst"
    MARKET_ANALYST = "market_analyst"
    COMPLIANCE_OFFICER = "compliance_officer"
    VEHICLE_VALUATOR = "vehicle_valuator"
    COORDINATOR = "coordinator"

@dataclass
class RiskAssessment:
    """Dataclass to hold the final, structured output of the risk assessment."""
    dealer_id: str
    risk_score: float  # A composite score from 0-100
    credit_rating: str  # A letter grade (e.g., AAA to D)
    max_loan_amount: float
    recommended_interest_rate: float
    recommendations: List[str]
    flags: List[str]
    timestamp: str
    component_scores: Dict[str, Any] # To see the breakdown from each agent

# --- Base Agent Class ---

class BaseAgent:
    """A base class defining the common structure and methods for all AI agents."""
    
    def __init__(self, role: AgentRole):
        self.role = role
        self.memory = []
        
    async def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        The core processing method for an agent. Must be implemented by subclasses.
        It takes raw data and returns a structured analysis.
        """
        raise NotImplementedError("Each agent must implement the 'process' method.")
        
    def log_activity(self, activity: str):
        """Logs an activity to the agent's memory for audit and debugging."""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "activity": activity
        }
        self.memory.append(log_entry)
        print(f"[{self.role.name}] {activity}")

# --- Specialized Agent Implementations ---

class CreditAnalystAgent(BaseAgent):
    """Analyzes a dealer's credit history and financial health."""
    
    def __init__(self):
        super().__init__(AgentRole.CREDIT_ANALYST)
        
    async def process(self, dealer_data: Dict[str, Any]) -> Dict[str, Any]:
        self.log_activity(f"Starting credit analysis for dealer ID: {dealer_data.get('id')}")
        
        total_loaned = dealer_data.get("total_loaned", 0)
        total_repaid = dealer_data.get("total_repaid", 0)
        active_loans = dealer_data.get("active_loans", 0)
        transactions = dealer_data.get("transactions", [])
        
        # Calculate repayment ratio (0 to 1)
        repayment_ratio = (total_repaid / total_loaned) if total_loaned > 0 else 0
        
        # Penalize for late payments
        late_payments = sum(1 for t in transactions if t.get("status") == "late")
        late_payment_penalty = late_payments * 5 # 5 points per late payment
        
        # Simplified credit score calculation (0-100)
        # A higher score is better.
        base_score = 100
        score = base_score * (repayment_ratio * 0.8 + 0.2) # Repayment ratio is 80% of the score
        score -= late_payment_penalty
        score -= active_loans * 2 # Minor penalty for each active loan
        
        credit_score = max(0, min(100, score)) # Clamp score between 0 and 100
        
        # Determine credit rating based on score
        if credit_score >= 90: rating = "AAA"
        elif credit_score >= 85: rating = "AA"
        elif credit_score >= 75: rating = "A"
        elif credit_score >= 65: rating = "BBB"
        elif credit_score >= 55: rating = "BB"
        elif credit_score >= 40: rating = "B"
        else: rating = "C"
        
        self.log_activity(f"Credit analysis complete. Score: {credit_score:.2f}, Rating: {rating}")
        
        return {
            "credit_score": credit_score,
            "credit_rating": rating,
            "repayment_ratio": repayment_ratio,
            "late_payments": late_payments
        }

class MarketAnalystAgent(BaseAgent):
    """Analyzes market conditions and the risk associated with a dealer's vehicle portfolio."""
    
    def __init__(self):
        super().__init__(AgentRole.MARKET_ANALYST)
        
    async def process(self, vehicle_data: Dict[str, Any]) -> Dict[str, Any]:
        self.log_activity("Analyzing market risk of vehicle portfolio.")
        
        vehicles = vehicle_data.get("vehicles", [])
        if not vehicles:
            return {"market_risk_score": 50, "diversity_score": 0, "avg_vehicle_price": 0}

        # Calculate portfolio diversity
        makes = {v['make'] for v in vehicles}
        diversity_score = min(100, len(makes) * 10) # 10 points per unique make, capped at 100
        
        # Calculate average price and age
        avg_price = sum(v['price'] for v in vehicles) / len(vehicles)
        current_year = datetime.utcnow().year
        avg_age = sum(current_year - v['year'] for v in vehicles) / len(vehicles)
        
        # Simplified market risk calculation (0-100)
        # A lower score is better.
        risk = 50 # Base risk
        if avg_price > 50000: risk += (avg_price - 50000) / 2000 # Higher avg price increases risk
        if diversity_score < 40: risk += (40 - diversity_score) # Low diversity increases risk
        if avg_age > 5: risk += (avg_age - 5) * 3 # Older inventory increases risk
        
        market_risk_score = max(0, min(100, risk))
        
        self.log_activity(f"Market analysis complete. Risk Score: {market_risk_score:.2f}")
        
        return {
            "market_risk_score": market_risk_score,
            "diversity_score": diversity_score,
            "avg_vehicle_price": avg_price
        }

class ComplianceOfficerAgent(BaseAgent):
    """Ensures compliance with regulations and platform policies."""
    
    def __init__(self):
        super().__init__(AgentRole.COMPLIANCE_OFFICER)
        
    async def process(self, dealer_data: Dict[str, Any]) -> Dict[str, Any]:
        self.log_activity("Checking dealer compliance status.")
        
        kyc_verified = dealer_data.get("kyc_status") == "approved"
        ach_connected = dealer_data.get("ach_connected", False)
        
        # Simplified compliance score (0-100)
        # A higher score is better.
        score = 0
        flags = []
        
        if kyc_verified:
            score += 50
        else:
            flags.append("KYC verification is not approved.")
            
        if ach_connected:
            score += 50
        else:
            flags.append("ACH bank account is not connected.")
        
        self.log_activity(f"Compliance check complete. Score: {score}, Flags: {len(flags)}")
        
        return {
            "compliance_score": score,
            "flags": flags
        }

class VehicleValuatorAgent(BaseAgent):
    """Evaluates the quality and total value of the vehicle collateral."""
    
    def __init__(self):
        super().__init__(AgentRole.VEHICLE_VALUATOR)
        
    async def process(self, vehicle_data: Dict[str, Any]) -> Dict[str, Any]:
        self.log_activity("Evaluating vehicle collateral.")
        
        vehicles = vehicle_data.get("vehicles", [])
        if not vehicles:
            return {"total_collateral_value": 0, "collateral_quality_score": 0}

        total_value = sum(v['price'] for v in vehicles)
        
        # Simplified collateral quality score (0-100)
        # A higher score is better.
        nfc_enabled_count = sum(1 for v in vehicles if v.get('nfc_tag_id'))
        nfc_ratio = nfc_enabled_count / len(vehicles)
        
        current_year = datetime.utcnow().year
        avg_age = sum(current_year - v['year'] for v in vehicles) / len(vehicles)
        
        quality_score = 100
        quality_score -= max(0, (avg_age - 3) * 10) # Penalize for avg age over 3 years
        quality_score = quality_score * (0.5 + nfc_ratio * 0.5) # Weight NFC enablement
        
        self.log_activity(f"Collateral valuation complete. Total Value: ${total_value:,.2f}")

        return {
            "total_collateral_value": total_value,
            "collateral_quality_score": max(0, min(100, quality_score))
        }

# --- Coordinator Agent ---

class RiskCoordinatorAgent(BaseAgent):
    """Orchestrates all other agents to produce a final, comprehensive risk assessment."""
    
    def __init__(self):
        super().__init__(AgentRole.COORDINATOR)
        # Instantiate all specialist agents
        self.agents = {
            AgentRole.CREDIT_ANALYST: CreditAnalystAgent(),
            AgentRole.MARKET_ANALYST: MarketAnalystAgent(),
            AgentRole.COMPLIANCE_OFFICER: ComplianceOfficerAgent(),
            AgentRole.VEHICLE_VALUATOR: VehicleValuatorAgent()
        }
        
    async def assess_risk(self, dealer_data: Dict[str, Any]) -> RiskAssessment:
        self.log_activity(f"Coordinating risk assessment for dealer ID: {dealer_data['id']}")
        
        # Run all agent analyses in parallel for efficiency
        tasks = [
            self.agents[AgentRole.CREDIT_ANALYST].process(dealer_data),
            self.agents[AgentRole.MARKET_ANALYST].process(dealer_data),
            self.agents[AgentRole.COMPLIANCE_OFFICER].process(dealer_data),
            self.agents[AgentRole.VEHICLE_VALUATOR].process(dealer_data)
        ]
        
        results = await asyncio.gather(*tasks)
        
        credit_result, market_result, compliance_result, valuator_result = results
        
        # --- Composite Risk Score Calculation ---
        # Weights can be tuned by governance in the future.
        weights = {
            "credit": 0.40,
            "market": 0.20,
            "compliance": 0.25,
            "collateral": 0.15
        }
        
        # Note: Market risk is inverted (100 - score) because lower is better.
        composite_score = (
            credit_result["credit_score"] * weights["credit"] +
            (100 - market_result["market_risk_score"]) * weights["market"] +
            compliance_result["compliance_score"] * weights["compliance"] +
            valuator_result["collateral_quality_score"] * weights["collateral"]
        )
        
        # --- Determine Loan Parameters ---
        
        # Max Loan-to-Value (LTV) ratio based on risk score
        ltv_ratio = 0.5 + (composite_score / 100) * 0.35  # Ranges from 50% to 85%
        max_loan = valuator_result["total_collateral_value"] * ltv_ratio
        
        # Recommended interest rate based on risk score
        base_rate = 8.0
        risk_premium = (100 - composite_score) / 100 * 5.0 # Premium up to 5% for high risk
        interest_rate = base_rate + risk_premium
        
        recommendations = []
        if interest_rate > 12:
            recommendations.append("High risk profile; consider additional collateral or guarantees.")
        if market_result['diversity_score'] < 30:
            recommendations.append("Portfolio lacks diversity; recommend financing a wider range of vehicle makes.")

        self.log_activity(f"Coordination complete. Final Risk Score: {composite_score:.2f}")

        return RiskAssessment(
            dealer_id=dealer_data["id"],
            risk_score=composite_score,
            credit_rating=credit_result["credit_rating"],
            max_loan_amount=max_loan,
            recommended_interest_rate=interest_rate,
            recommendations=recommendations,
            flags=compliance_result["flags"],
            timestamp=datetime.utcnow().isoformat(),
            component_scores={
                "credit": credit_result,
                "market": market_result,
                "compliance": compliance_result,
                "collateral": valuator_result
            }
        )

# --- Main Execution Block (for demonstration) ---

async def main():
    """
    Main function to demonstrate the functionality of the risk assessment swarm.
    In a real application, this logic would be part of a service layer
    called by an API endpoint.
    """
    # Mock data representing what would be fetched from the ANVL database
    mock_dealer_data = {
        "id": "DEALER-001",
        "name": "Prestige Auto Group",
        "kyc_status": "approved",
        "ach_connected": True,
        "total_loaned": 500000,
        "total_repaid": 450000,
        "active_loans": 3,
        "transactions": [
            {"date": "2025-06-01", "amount": 10000, "status": "on_time"},
            {"date": "2025-07-01", "amount": 10000, "status": "on_time"},
            {"date": "2025-07-15", "amount": 5000, "status": "late"},
        ],
        "vehicles": [
            {"vin": "123ABC...", "make": "BMW", "model": "X5", "year": 2022, "price": 55000, "nfc_tag_id": "NFC-A1"},
            {"vin": "456DEF...", "make": "Mercedes-Benz", "model": "C-Class", "year": 2021, "price": 45000, "nfc_tag_id": "NFC-B2"},
            {"vin": "789GHI...", "make": "Audi", "model": "Q7", "year": 2023, "price": 65000, "nfc_tag_id": "NFC-C3"},
            {"vin": "101JKL...", "make": "BMW", "model": "3 Series", "year": 2020, "price": 38000, "nfc_tag_id": None},
        ]
    }

    print("--- Starting ANVL Risk Assessment Swarm ---")
    
    # Initialize the coordinator
    coordinator = RiskCoordinatorAgent()
    
    # Run the assessment
    final_assessment = await coordinator.assess_risk(mock_dealer_data)
    
    print("\n--- Assessment Complete ---")
    # Pretty-print the final assessment dataclass as a JSON object
    print(json.dumps(asdict(final_assessment), indent=4))
    print("-------------------------\n")


if __name__ == "__main__":
    asyncio.run(main())
